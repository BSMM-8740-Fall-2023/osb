---
title: "Introduction to the Tidyverse"
subtitle: "BSMM-8740 - Fall 2023"
author: "Dr. L.L. Odette"
footer:  "[bsmm-8740-fall-2023.github.io/osb](https://bsmm-8740-fall-2023.github.io/osb/)"
logo: "images/logo.png"
format: 
  revealjs: 
    theme: slides.scss
    multiplex: true
    transition: fade
    slide-number: true
editor: visual
execute:
  freeze: auto
---

```{r setup}
#| include: false
library(countdown)
knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = 0.618,
  fig.align = "center",
  out.width = "90%"
)
```

```{r packages}
#| echo: false
#| message: false

# load packages
library(tidyverse)       # for data wrangling
library(tidymodels)      # for modeling
library(fivethirtyeight) # for the fandango dataset

# set default theme and larger font size for ggplot2
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 16))

# set default figure parameters for knitr
knitr::opts_chunk$set(
  fig.width = 8,
  fig.asp = 0.618,
  fig.retina = 3,
  dpi = 300,
  out.width = "80%"
)
```

# Welcome

## Announcements

-   If you're just joining the class, welcome! Go to the [course website](https://bsmm-8740-fall-2023.github.io/osb/) and review content you've missed, read the syllabus, and complete the *Getting to know you* survey.
-   Lab 1 is due Friday, at 5pm, on Gradescope.

## Outline

-   Introduction to Tidy data & Tidyverse syntax
-   Estimate the slope and intercept of the regression line using the least squares method
-   Interpret the slope and intercept of the regression line

## Tidy Data

A dataset is a collection of **values**, usually either numbers (if quantitative) or strings (if qualitative). Values are organised in two ways. Every value belongs to a **variable** and an **observation**. A variable contains all values that measure the same underlying attribute (like height, temperature, duration) across units. An observation contains all values measured on the same unit (like a person, or a day, or a race) across attributes.

## Tidy Data

In **tidy data**:

-   Every column is a variable.
-   Every row is an observation.
-   Every cell is a single value.

## Tidy Data Examples

::: panel-tabset
## table 1

```{r}
tidyr::table1
```

## table 2

```{r}
tidyr::table2
```

## table 3

```{r}
tidyr::table3
```
:::

## Tidyverse Principles

From Wickham et al. ("Welcome to the Tidyverse." *Journal of Open Source Software* 4 (43)):

> "At a high level, the tidyverse is a language for solving data science challenges with R code. Its primary goal is to facilitate a conversation between a human and a computer about data. Less abstractly, the tidyverse is a collection of R packages that share a high-level design philosophy and low-level grammar and data structures, so that learning one package makes it easier to learn the next."

## Principles

1.  Design for humans
2.  Reuse existing data structures
3.  Design for the pipe and functional programming

## Example

```{r}
#| echo: true
#| message: false
# attach package magrittr
require(magrittr)

url <- 
  "https://data.cityofchicago.org/api/views/5neh-572f/rows.csv?accessType=DOWNLOAD&bom=true&format=true"

all_stations <- 
  # Step 1: Read in the data.
  readr::read_csv(url) %>% 
  # Step 2: filter columns and rename stationname
  dplyr::select(station = stationname, date, rides) %>% 
  # Step 3: Convert the character date field to a date encoding.
  # Also, put the data in units of 1K rides
  dplyr::mutate(date = lubridate::mdy(date), rides = rides / 1000) %>% 
  # Step 4: Summarize the multiple records using the maximum.
  dplyr::group_by(date, station) %>% 
  dplyr::summarize(rides = max(rides), .groups = "drop")
```

## Magrittr vs native pipe

::: {style="font-size: 80%"}
| Topic         | Magrittr *2.0.3*     | Base *4.3.0*                       |
|---------------|----------------------|------------------------------------|
| Operator      | `%>%` `%<>%` `%T>%`  | `|>` (since 4.1.0)                 |
| Function call | `1:3 %>% sum()`      | `1:3 %>% sum()`                    |
|               | `1:3 %>% sum`        | *Needs brackets / parentheses*     |
|               | `` 1:3 %>% `+`(4) `` | *Some functions are not supported* |
| Placeholder   | `.`                  | `_` (since 4.2.0)                  |
:::

~based on [stackoverflow](https://stackoverflow.com/questions/67633022/what-are-the-differences-between-rs-new-native-pipe-and-the-magrittr-pipe)~

## Use cases for the Magrittr pipe

```{r}
#| echo: true
#| message: false
#| results: false
# functional programming
airlines <- fivethirtyeight::airline_safety %>% 
  # filter rows
  dplyr::filter( stringr::str_detect(airline, 'Air') )

# assignment
airlines %<>% 
  # filter columns and assign result to airlines
  dplyr::select(avail_seat_km_per_week, incidents_85_99, fatalities_85_99)

# side effects
airlines %T>% 
  # report the dimensions
  (\(x) print(dim(x)) ) %>% 
  # summarize
  dplyr::summarize(avail_seat_km_per_week = sum(avail_seat_km_per_week))
```

## Functions in R

```{r}
#| echo: true
#| message: false
#| results: false
# named function
is_awesome <- function(x = 'Bob') {
  paste(x, 'is awesome!')
}

# anonymous function
(function (x) {paste(x, 'is awesome!')})('Keith')

# also anonymous function
(\(x) paste(x, 'is awesome!'))('Keith')

# a function from a formula in the tidyverse
c('Bob','Ted') %>% purrr::map_chr(~paste(.x, 'is awesome!'))
```

# Data Wrangling

## Example 1a: mutate

```{r}
#| echo: true
#| message: false
#| results: false
openintro::email %>%
  dplyr::select(-from, -sent_email) %>%
  dplyr::mutate(
    day_of_week = lubridate::wday(time)       # new variable: day of week
    , month = lubridate::month(time)          # new variable: month
  ) %>%
  dplyr::select(-time) %>%
  dplyr::mutate(
    cc     = cut(cc, breaks = c(0, 1))        # discretize cc
    , attach = cut(attach, breaks = c(0, 1))  # discretize attach
    , dollar = cut(dollar, breaks = c(0, 1))  # discretize dollar
  ) %>%
  dplyr::mutate(
    inherit = 
      cut(inherit, breaks = c(0, 1, 5, 10, 20))  # discretize inherit, by intervals
    , password = dplyr::ntile(password, 5)       # discretize password, by quintile
  )
```

## Example 1b: mutate across

```{r}
#| echo: true
#| message: false
#| results: false
iris %>%
  dplyr::mutate(across(c(Sepal.Length, Sepal.Width), round))

iris %>%
  dplyr::mutate(across(c(1, 2), round))

iris %>%
  dplyr::group_by(Species) %>%
  dplyr::summarise(
    across( starts_with("Sepal"), list(mean = mean, sd = sd) )
  )

iris %>%
  dplyr::group_by(Species) %>%
  dplyr::summarise(
    across( starts_with("Sepal"), ~ mean(.x, na.rm = TRUE) )
  )

```

## Example 2: rowwise operations

::: panel-tabset
## rowwise operations

The verb ***rowwise*** creates a special type of grouping where each group consists of a single row.

```{r}
#| echo: true
#| message: false
#| results: false
iris %>%
  dplyr::rowwise() %>%
  dplyr::mutate( 
    mean_length = 
      mean( c(Sepal.Length, Petal.Length) )
    , .before = 1
  ) %>% 
  dplyr::ungroup()
```

## using c_across

```{r}
#| echo: true
#| message: false
#| results: false
iris %>%
  dplyr::rowwise() %>%
  dplyr::mutate( 
    mean_length = 
      mean(
        dplyr::c_across(c(Sepal.Length:Petal.Width))
      )
    , .before = 1 
  ) %>% 
  dplyr::ungroup()
```
:::

## Example 3: nesting operations

::: panel-tabset
## list columns

```{r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "create a list-column of data frames"
(df1 <- tibble::tibble(
  g = c(1, 2, 3),
  data = list(
    tibble::tibble(x = 1, y = 2),
    tibble::tibble(x = 4:5, y = 6:7),
    tibble::tibble(x = 10)
  )
) )
```

## group-nesting

```{r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "nest groups by continent, country"
(gapminder_nest <- gapminder::gapminder %>% 
  dplyr::mutate(year1950 = year - 1950) %>% 
  dplyr::group_nest(continent, country)
)
```

## mapping

```{r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Fit a linear model for each country:"
(gapminder_model <- gapminder_nest %>% 
  dplyr::mutate(
    model = 
      purrr::map(
        data
        , ~lm(lifeExp ~ year1950, data = .))
  ))
```
:::

## Example 4: stringr string functions

Main verbs, each taking a pattern as input

::: panel-tabset
## stringr::str\_{X}

```{r}
#| echo: true
#| message: false
#| results: false
x <- c("why", "video", "cross", "extra", "deal", "authority")

stringr::str_detect(x, "[aeiou]")       # identifies any matches
stringr::str_count(x, "[aeiou]")        # counts number of patterns
stringr::str_subset(x, "[aeiou]")       # extracts matching components
stringr::str_extract(x, "[aeiou]")      # extracts text of the match
stringr::str_replace(x, "[aeiou]", "?") # replaces matches with new text:
stringr::str_split(x, ",")              # splits up a string

```

## stringr::str_glue

```{r}
#| echo: true
#| message: false
#| results: false

mtcars %>% 
  tibble::rownames_to_column(var = "car") %>% 
  tibble::as_tibble() %T>% 
  (\(x) print(names(x)) ) %>% 
  dplyr::mutate(
    note = stringr::str_glue("The {car} has {cyl} cylinders")) %>% 
  dplyr::slice_head(n=3)
```
:::

[cheat sheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf)

## Example 5: Database functions

::: panel-tabset
## Create DB

```{r}
#| echo: true
#| eval: false
#| message: false
# directly like a tibble
db <- 
  dbplyr::memdb_frame(
    x = runif(100)
    , y = runif(100)
    , .name = 'test_tbl'
  )

# using an existing table
mtcars_db <- dbplyr::tbl_memdb(mtcars)
```

```{r}
#| echo: false
#| message: false
#| results: false
mtcars_db <- dbplyr::tbl_memdb(mtcars)
```

## Extract SQL

```{r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Generate SQL without executing"
mtcars_db %>% 
  dplyr::group_by(cyl) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::show_query()
```

## Execute Query

```{r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Execute Query on DB"
mtcars_db %>% 
  dplyr::group_by(cyl) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::collapse()
```
:::

## Pivoting

::: panel-tabset
## longer

When some of the column names are not names of variables, but *values* of a variable.

::: columns
::: {.column width="50%"}
```{r}
tidyr::table4a
```
:::

::: {.column width="50%"}
```{r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Pivot longer"
tidyr::table4a %>% 
  pivot_longer(
    c(`1999`, `2000`)
    , names_to = "year", values_to = "cases")
```
:::
:::

## wider

When an observation is scattered across multiple rows.

::: columns
::: {.column width="50%" style="font-size: smaller"}
```{r}
tidyr::table2
```
:::

::: {.column width="50%" style="font-size: smaller"}
```{r}
#| echo: true
#| message: false
#| code-fold: true
#| code-summary: "Pivot wider"
tidyr::table2 %>%
    pivot_wider(
      names_from = type
      , values_from = count)
```
:::
:::
:::

## Relational data

see: [relational data](https://r4ds.had.co.nz/relational-data.html)

# Exercises in data wrangling

# Recap

## Recap {.smaller}

::: incremental
-   Used simple linear regression to describe the relationship between a quantitative predictor and quantitative outcome variable.

-   Used the least squares method to estimate the slope and intercept.å

-   We interpreted the slope and intercept.

    ::: incremental
    -   **Slope:** For every one unit increase in $x$, we expect y to be higher/lower by $\hat{\beta}_1$ units, on average.
    -   **Intercept:** If $x$ is 0, then we expect $y$ to be $\hat{\beta}_0$ units.
    :::

-   Predicted the response given a value of the predictor variable.

-   Defined extrapolation and why we should avoid it.
:::
